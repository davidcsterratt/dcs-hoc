fprint("utils_ver = '$Revision: 1.10 $';\n")

//
// error(String error) 
//
// Issue error string and stop simulation
//

proc error() {
    print $s1
    stop
}

//
// x = min(double a, double b)
// 
// return minimum of a and b
//

func min() {
    if ( $1 < $2 ) { return $1 } else { return $2 }
}

//
// x = max(double a, double b)
// 
// return maximum of a and b
//

func max() {
    if ( $1 > $2 ) { return $1 } else { return $2 }
}

//
// setprintmpar( File file, "parameter_name", parameter_value)
// 
// set parameter of paramater_name to parameter_value and print
// the parameter name and value to file.
// 

strdef utils_printmprefix
strdef utils_tmpstr
proc setprintmpar () {
    sprint(utils_tmpstr, "%s = %g", $s2, $3)
    execute(utils_tmpstr)
    printmdouble($o1, $3, $s2)
    execute(utils_tmpstr)
}

//
// printmstr(file_handle, string, "string_name")
// 
// Print string to file_handle in matlab format with name string_name.
// 

proc printmstr () { 
    $o1.printf("%s%s = ", utils_printmprefix, $s3)
    $o1.printf("'%s' ", $s2)
    $o1.printf(" ;\n")
}

//
// printmdouble(file_handle, double, "double_name")
// 
// Print double to file_handle in matlab format with name double_name.
// 

proc printmdouble () { 
    $o1.printf("%s%s = [ ", utils_printmprefix, $s3)
    $o1.printf("%g ", $2)
    $o1.printf(" ];\n")
}

//
// printmvec(file_handle, vector, "vector_name")
// 
// Print vector to file_handle in matlab format with name vector_name.
// If vector is longer than the local varible chunk_size, it is split 
// into lines of chunk_size elements or less, separated by the matlab line 
// continuation symbol "...".  
// 
// printmvec(file_handle, vector, "vector_name", start, end)
// 
// Same as above, but only print from index start to index end.  
// The start and end indeicies are in the range 0 to vector.size()-1 , 
// i.e. the NEURON/C convention rather than Matlab convetion.  They 
// will, however, be printed in Matlab convention.
//
// printmvec(file_handle, vector, "vector_name", start, end, row)
// 
// Same as above, but print vector as row of matrix.  Again, indicies
// are from 0 to vector.size()-1.


proc printmvec () { local i, chunk_size, start, end, total_size, pos, name, blockend, row
    chunk_size = 10             // How many elements per line to print
    block_size = 100            // How many elements per vector to print
    utils_tmpstr = ""
    
    //
    // Deal with input arguments
    //
    
    if (numarg() == 3) {
        start = 0
        end = $o2.size() - 1
    }

    if (numarg() >= 5) {
        start = $4
        end = $5
        if (start != int(start)) { error("utils.hoc:printmvec(): start value is not an integer")}
        if (end != int(end)) { error("utils.hoc:printmvec(): end value is not an integer") }
        if (end < start ) { error("utils.hoc:printmvec(): end value is lower than start value") }
    }

    if (numarg() == 6) {
        row = $6
        sprint(utils_tmpstr,"%g,",row + 1)
    }
    
    //
    // Print out values
    //
    
    // Only print if there are values to print
    if ( (end-start) >= 0 ) {

        // Loop throgh values
        for j = start, end {

            // Split vector into new vector every block_size elements 
            // as long as we're not at the end of the vector
            if (((j-start) % block_size) == 0) {

                // If not at the start of the vector, need to finish old 
                // vector
                if ( j != start ) {
                    $o1.printf("];\n") 
                }
                $o1.printf("%s%s(%s%g:%g) = [ ", utils_printmprefix, $s3, utils_tmpstr, j+1, min((j+block_size),end+1))
            }
            
            // Newline and ... every chunk_size elements
            if ( ( ( j - start  ) % chunk_size ) == 0 ) {
                $o1.printf(" ...\n") 
            }
            
            // Print out element itself
            $o1.printf("%g ", $o2.x(j))
        }
        
        // Print end of vector
        $o1.printf("];\n") 
    }
}

objref utils_p 
proc test_pointer () {
    utils_p = new Pointer($s1)
    print utils_p.val
    print utils_p.s
}
       
proc test_local () { local a 
    execute1("a = b",this)
   // a = b
    a = a + 1 
    print a
    execute1("b = a",this)
  //  b = a
    print b
}

//
// SpikeList - list of neurons and spike times
//
// sl = new SpikeList("name",n) - creates SpikeList sl that contains
//                                the times of n neurons and will write 
//                                to a vector called "name"
// sl.printmtimes(File f)       - print times of spikes in my matlab
//                                [neuron_number time] format 
// sl.times.object(i)           - The ith spike time vector
//

begintemplate SpikeList

external min, max, utils_printmprefix
public cell, clear, pos, name, times, n, printmtimes
objref times                     // Spike time list
strdef name

proc init() { local i
    pos = 1                     // Position -- i.e. total number 
                                // of unprinted spikes
    times = new List()
    name = $s1
    n = $2                      // Number of cells in group
    for i = 0, n-1 { times.append(new Vector()) }
}

proc printmtimes() { local i, j, total_size, blockend, end
    
    // Find out how many spikes need to be printed in total
    total_size=0
    for i = 0, n-1 { total_size = total_size + times.object(i).size() }
//    printf("total_size: %g\n", total_size)
//    printf("pos: %g\n", pos)

    // Print out spikes
    if (total_size >= 1 ) {
        // We want blocks of 100 lines or less
        end = pos + total_size
        blockend = min(end, pos + 100) 
        
        $o1.printf("%s%s(%g:%g,:) = [ ...\n", utils_printmprefix, name, pos, blockend - 1)
        for i=0, n-1 {
            for j=0, times.object(i).size() - 1 {
                $o1.printf("%4.0f %g; ... \n", i+1, times.object(i).x(j))
                pos = pos + 1
                // Reached the end of this block?
                if ( pos == blockend ) { 
                    $o1.printf("];\n") 
                    // Reached the end of all the data?
                    if ( pos != end ) {
                        blockend = min(end, pos + 100) 
                        $o1.printf("%s%s(%g:%g,:) = [ ...\n", utils_printmprefix, name, pos, blockend - 1)
                    }
                }
            }
            times.object(i).resize(0) // Clear the vector
        }
    }
} 

endtemplate SpikeList