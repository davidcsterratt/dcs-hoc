fprint("utils_ver = '$Revision: 1.9 $';\n")

//
// error(String error) 
//
// Issue error string and stop simulation
//

proc error() {
    print $s1
    stop
}

//
// x = min(double a, double b)
// 
// return minimum of a and b
//

func min() {
    if ( $1 < $2 ) { return $1 } else { return $2 }
}

//
// x = max(double a, double b)
// 
// return maximum of a and b
//

func max() {
    if ( $1 > $2 ) { return $1 } else { return $2 }
}

//
// setprintmpar("parameter_name", parameter_value)
// 
// set parameter of paramater_name to parameter_value and print
// the parameter name and value to the default open file (open with 
// IO-wopen().
// 

strdef utils_tmpstr
proc setprintmpar () { 
    sprint(utils_tmpstr, "%s = %g", $s1, $2)
    execute(utils_tmpstr)
    sprint(utils_tmpstr, "fprint(\"%s = %g ;\\n\", %s )", $s1, $2, $s1)
    execute(utils_tmpstr)
}

//
// printmdouble(file_handle, double, "double_name")
// 
// Print double to file_handle in matlab format with name double_name.
// 

proc printmdouble () { 
    $o1.printf("%s = [ ", $s3)
    $o1.printf("%g ", $2)
    $o1.printf(" ];\n")
}

//
// printmvec(file_handle, vector, "vector_name")
// 
// Print vector to file_handle in matlab format with name vector_name.
// If vector is longer than the local varible chunk_size, it is split 
// into lines of chunk_size elements or less, separated by the matlab line 
// continuation symbol "...".  
// 
// printmvec(file_handle, vector, "vector_name", start, end)
// 
// Same as above, but only print from index start to index end
//

proc printmvec () { local i, chunk_size, start, end, total_size, pos, name, blockend
    chunk_size = 10             // How many figures per line to print
    pos = 1                     // Position -- i.e. total number 
                                // of unprinted spikes

    if (numarg() == 3) {
        start = 0 
        end = $o2.size() - 1 
    } else {
        start = $4
        end = $5
        if (start != int(start)) { error("utils.hoc:printmvec(): start value is not an integer")}
        if (end != int(end)) { error("utils.hoc:printmvec(): end value is not an integer") }
        if (end < start ) { error("utils.hoc:printmvec(): end value is lower than start value") }
    }
    
    // Find out how many values need to be printed in total
    total_size = $o2.size() 
    //    printf("total_size: %g\n", total_size)
    //    printf("pos: %g\n", pos)
    
    // Print out values
    if (total_size >= 1 ) {
        // We want blocks of 100 lines or less
        end = pos + total_size
        blockend = min(end, pos + 100) 
        
        $o1.printf("%s(%g:%g) = [ ...\n", $s3, pos, blockend - 1)
        for j=0, $o2.size() - 1 {
            $o1.printf("%g ", $o2.x(j))
            if ( ( ( j + 1 ) % chunk_size ) == 0 ) {
                $o1.printf(" ...\n") 
            }
            pos = pos + 1
            // Reached the end of this block?
            if ( pos == blockend ) { 
                $o1.printf("];\n") 
                // Reached the end of all the data?
                if ( pos != end ) {
                    blockend = min(end, pos + 100) 
                    $o1.printf("%s(%g:%g) = [ ...\n", $s3, pos, blockend - 1)
                }
            }
        }
    }

//    print start, end
//    $o1.printf("%s = [ ", $s3)
//    for i = start, end {
//        $o1.printf("%g ", $o2.x(i))
//    }
//    $o1.printf(" ];\n")
}

objref utils_p 
proc test_pointer () {
    utils_p = new Pointer($s1)
    print utils_p.val
    print utils_p.s
}
       
proc test_local () { local a 
    execute1("a = b",this)
   // a = b
    a = a + 1 
    print a
    execute1("b = a",this)
  //  b = a
    print b
}

//
// SpikeList - list of neurons and spike times
//
// sl = new SpikeList("name",n) - creates SpikeList sl that contains
//                                the times of n neurons and will write 
//                                to a vector called "name"
// sl.printmtimes(File f)       - print times of spikes in my matlab
//                                [neuron_number time] format 
// sl.times.object(i)           - The ith spike time vector
//

begintemplate SpikeList

external min, max
public cell, clear, pos, name, times, n, printmtimes
objref times                     // Spike time list
strdef name

proc init() { local i
    pos = 1                     // Position -- i.e. total number 
                                // of unprinted spikes
    times = new List()
    name = $s1
    n = $2                      // Number of cells in group
    for i = 0, n-1 { times.append(new Vector()) }
}

proc printmtimes() { local i, j, total_size, blockend, end
    
    // Find out how many spikes need to be printed in total
    total_size=0
    for i = 0, n-1 { total_size = total_size + times.object(i).size() }
//    printf("total_size: %g\n", total_size)
//    printf("pos: %g\n", pos)

    // Print out spikes
    if (total_size >= 1 ) {
        // We want blocks of 100 lines or less
        end = pos + total_size
        blockend = min(end, pos + 100) 
        
        $o1.printf("%s(%g:%g,:) = [ ...\n", name, pos, blockend - 1)
        for i=0, n-1 {
            for j=0, times.object(i).size() - 1 {
                $o1.printf("%4.0f %g; ... \n", i+1, times.object(i).x(j))
                pos = pos + 1
                // Reached the end of this block?
                if ( pos == blockend ) { 
                    $o1.printf("];\n") 
                    // Reached the end of all the data?
                    if ( pos != end ) {
                        blockend = min(end, pos + 100) 
                        $o1.printf("%s(%g:%g,:) = [ ...\n", name, pos, blockend - 1)
                    }
                }
            }
            times.object(i).resize(0) // Clear the vector
        }
    }
} 

endtemplate SpikeList