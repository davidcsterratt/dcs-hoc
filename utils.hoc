fprint("utils_ver = '$Revision: 1.6 $';\n")

//
// error(String error) 
//
// Issue error string and stop simulation
//

proc error() {
    print $s1
    stop
}

//
// x = min(double a, double b)
// 
// return minimum of a and b
//

func min() {
    if ( $1 < $2 ) { return $1 } else { return $2 }
}

//
// x = max(double a, double b)
// 
// return maximum of a and b
//

func max() {
    if ( $1 > $2 ) { return $1 } else { return $2 }
}
 
//
// setprintmpar("parameter_name", parameter_value)
// 
// set parameter of paramater_name to parameter_value and print
// the parameter name and value to the default open file (open with 
// IO-wopen().
// 

strdef utils_tmpstr
proc setprintmpar () { 
    sprint(utils_tmpstr, "%s = %g", $s1, $2)
    execute(utils_tmpstr)
    sprint(utils_tmpstr, "fprint(\"%s = %g ;\\n\", %s )", $s1, $2, $s1)
    execute(utils_tmpstr)
}

//
// printmvec(file_handle, vector, "vector_name")
// 
// Print vector to file_handle in matlab format with name vector_name.
// If vector is longer than the local varible chunk_size, it is split 
// into lines of chunk_size elements or less, separated by the matlab line 
// continuation symbol "...".  
// 
// printmvec(file_handle, vector, "vector_name", start, end)
// 
// Same as above, but only print from index start to index end
//

proc printmvec () { local i, chunk_size, start, end
    chunk_size = 10             // How many figures per line to print

    if (numarg() == 3) {
        start = 0 
        end = $o2.size() - 1 
    } else {
        start = $4
        end = $5
        if (start != int(start)) { error("utils.hoc:printmvec(): start value is not an integer")}
        if (end != int(end)) { error("utils.hoc:printmvec(): end value is not an integer") }
        if (end < start ) { error("utils.hoc:printmvec(): end value is lower than start value") }
    }

//    print start, end
    $o1.printf("%s = [ ", $s3)
    for i = start, end {
        $o1.printf("%8.2f ", $o2.x(i))
        if ( ( ( i + 1 ) % chunk_size ) == 0 ) {
            $o1.printf(" ...\n") 
        }
    }
    $o1.printf(" ];\n")
}

//
// printmdouble(file_handle, double, "double_name")
// 
// Print double to file_handle in matlab format with name double_name.
// If double is longer than the local varible chunk_size, it is split 
// into lines of chunk_size elements or less, separated by the matlab line 
// continuation symbol "...".  
// 

proc printmdouble () { 
    $o1.printf("%s = [ ", $s3)
    $o1.printf("%8.2f ", $2)
    $o1.printf(" ];\n")
}

//
// printmspiketimes(File f, List spiketimes, String spiketimes)
//
// Print list of vectors of spike times spiketimes to array matlab 
// format with each line of the array being in the form 
// neuron_number, spike_time.  
// The neuron_number allocated is the array index + 1.  The string 
// spiketimes is the name of the matlab array printed to.  
// n specifies the size of the array
//

proc printmspiketimes() { local i, j, total_size, pos, n
    n = $o2.count()
    // Create the variable "printmspiketims_spiketimes_pos") if 
    // it doesn't exist
    sprint(utils_tmpstr,"printmspiketimes_%s_pos",$s3)
    if( !name_declared(utils_tmpstr) ) {
        sprint(utils_tmpstr,"printmspiketimes_%s_pos = 1",$s3)
        execute1(utils_tmpstr) 
    }
    sprint(utils_tmpstr,"pos = printmspiketimes_%s_pos",$s3)
    print utils_tmpstr
    execute1(utils_tmpstr)
    print "pos:", pos, " total_size:", total_size 
    sprint(utils_tmpstr,"print \"printmspiketimes_%s_pos:\", printmspiketimes_%s_pos", $s3, $s3)
    execute1(utils_tmpstr)
    
    // Find out how many spikes need to be printed in total
    total_size=0
    for i = 0, n-1 { total_size = total_size + $o2.object(i).size() }
    // Print out spikes
    if (total_size >= 1 ) {
        // We want blocks of 100 lines or less
        end = pos + total_size
        blockend = min(end, pos + 100) 
        sprint(utils_tmpstr,"%s(%g:%g,:) = [ ...\n", $s3, pos, blockend - 1)
        $o1.printf("%s",utils_tmpstr)
        for i=0, n-1 {
            for j=0, $o2.object(i).size() - 1 {
                $o1.printf("%4.0f %g; ... \n", i, $o2.object(i).x(j))
                pos = pos + 1
                // Reached the end of this block?
                if ( pos == blockend ) { 
                    $o1.printf("];\n") 
                    // Reached the end of all the data?
                    if ( pos != end ) {
                        blockend = min(end, pos + 100) 
                        sprint(utils_tmpstr,"%s(%g:%g,:) = [ ...\n", $s3, pos, blockend - 1)
                        $o1.printf("%s",utils_tmpstr)
                    }
                }
            }
            $o2.object(i).resize(0) // Clear the vector
        }
    } 
    
    // Read the pos information back to the static variable
    sprint(utils_tmpstr,"printmspiketimes_%s_pos = pos",$s3)
    execute1(utils_tmpstr)
}

objref utils_p 
proc test_pointer () {
    utils_p = new Pointer($s1)
    print utils_p.val
    print utils_p.s
}
       
proc test_local () { local a 
    execute1("a = b",this)
   // a = b
    a = a + 1 
    print a
    execute1("b = a",this)
  //  b = a
    print b
}

//
// SpikeList - list of neurons and spike times
//
// sl = new SpikeList("name",n) - creates SpikeList sl that contains
//                                the times of n neurons and will write 
//                                to a vector called "name"
// sl.printmtimes(File f)       - print times of spikes in my matlab
//                                [neuron_number time] format 
// sl.times.object(i)           - The ith spike time vector
//

begintemplate SpikeList

external min, max
public cell, clear, pos, name, times, n, printmtimes
objref times                     // Spike time list
strdef name

proc init() { local i
    pos = 1                     // Position -- i.e. total number 
                                // of unprinted spikes
    times = new List()
    name = $s1
    n = $2                      // Number of cells in group
    for i = 0, n-1 { times.append(new Vector()) }
}

proc printmtimes() { local i, j, total_size, blockend, end
    
    // Find out how many spikes need to be printed in total
    total_size=0
    for i = 0, n-1 { total_size = total_size + times.object(i).size() }
//    printf("total_size: %g\n", total_size)
//    printf("pos: %g\n", pos)

    // Print out spikes
    if (total_size >= 1 ) {
        // We want blocks of 100 lines or less
        end = pos + total_size
        blockend = min(end, pos + 100) 
        
        $o1.printf("%s(%g:%g,:) = [ ...\n", name, pos, blockend - 1)
        for i=0, n-1 {
            for j=0, times.object(i).size() - 1 {
                $o1.printf("%4.0f %g; ... \n", i+1, times.object(i).x(j))
                pos = pos + 1
                // Reached the end of this block?
                if ( pos == blockend ) { 
                    $o1.printf("];\n") 
                    // Reached the end of all the data?
                    if ( pos != end ) {
                        blockend = min(end, pos + 100) 
                        sprint(utils_tmpstr,"%s(%g:%g,:) = [ ...\n", name, pos, blockend - 1)
                        $o1.printf("%s",utils_tmpstr)
                    }
                }
            }
            times.object(i).resize(0) // Clear the vector
        }
    }
} 

endtemplate SpikeList